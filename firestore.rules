rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Users collection
    match /users/{userId} {
      // Anyone authenticated can read user profiles (for search)
      allow read: if request.auth != null;
      // Only the user themselves can write their own profile
      allow write: if request.auth != null && request.auth.uid == userId;

      // Friends subcollection
      match /friends/{friendId} {
        // Owner can do anything with their friends list
        allow read, create, update: if request.auth != null && request.auth.uid == userId;
        // Owner OR the friend themselves can delete (for mutual unfriend/block)
        allow delete: if request.auth != null
                      && (request.auth.uid == userId || request.auth.uid == friendId);
        // The friend can create their own entry (for accept friend request)
        allow create: if request.auth != null && request.auth.uid == friendId;
      }

      // Blocked users subcollection
      match /blocked/{blockedId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Conversations collection
    match /conversations/{conversationId} {
      // Only participants can read the conversation
      allow read: if request.auth != null
                  && request.auth.uid in resource.data.participants;
      // Only participants can update the conversation (e.g. lastMessage)
      allow update: if request.auth != null
                    && request.auth.uid in resource.data.participants;
      // Authenticated users can create conversations (they must be a participant)
      allow create: if request.auth != null
                    && request.auth.uid in request.resource.data.participants;

      // Messages subcollection
      match /messages/{messageId} {
        // Only conversation participants can read messages
        allow read: if request.auth != null
                    && request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
        // Only conversation participants can send messages, senderId must match auth
        allow create: if request.auth != null
                      && request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants
                      && request.resource.data.senderId == request.auth.uid;
        // Allow updating read status by participants
        allow update: if request.auth != null
                      && request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
      }
    }

    // LFG Posts collection
    match /lfgPosts/{postId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null
                    && request.resource.data.authorId == request.auth.uid
                    && request.resource.data.status == "active"
                    && request.resource.data.description is string
                    && request.resource.data.description.size() <= 500
                    && request.resource.data.categoryId is number
                    && request.resource.data.platform is string
                    && request.resource.data.language is string;
      allow update: if request.auth != null
                    && resource.data.authorId == request.auth.uid
                    && request.resource.data.authorId == resource.data.authorId
                    && request.resource.data.categoryId == resource.data.categoryId;
      allow delete: if request.auth != null
                    && resource.data.authorId == request.auth.uid;
    }

    // Drama Clubs collection
    match /dramaClubs/{clubSlug} {
      allow read: if request.auth != null;
      // Anyone authenticated can create a club (auto-created on first entry)
      allow create: if request.auth != null
                    && request.resource.data.createdBy == request.auth.uid;
      // Only counter fields updated via entry creation (by any authenticated user)
      allow update: if request.auth != null;

      // Members subcollection
      match /members/{memberId} {
        allow read: if request.auth != null;
        // User can only create their own membership doc
        allow create: if request.auth != null
                      && request.auth.uid == memberId;
        allow update: if request.auth != null
                      && request.auth.uid == memberId;
        allow delete: if request.auth != null
                      && request.auth.uid == memberId;
      }
    }

    // Drama Entries collection
    match /dramaEntries/{entryId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null
                    && request.resource.data.authorId == request.auth.uid
                    && request.resource.data.status == "active"
                    && request.resource.data.title is string
                    && request.resource.data.title.size() <= 200
                    && request.resource.data.body is string
                    && request.resource.data.body.size() <= 5000;
      // Author can update (soft delete), counters updated by vote/comment system
      allow update: if request.auth != null;
      allow delete: if false; // Soft delete only

      // Entry votes subcollection
      match /votes/{oderId} {
        allow read: if request.auth != null;
        // User can only write their own vote (doc ID must match auth uid)
        allow create, update: if request.auth != null
                              && request.auth.uid == oderId;
        allow delete: if request.auth != null
                      && request.auth.uid == oderId;
      }
    }

    // Drama Comments collection
    match /dramaComments/{commentId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null
                    && request.resource.data.authorId == request.auth.uid
                    && request.resource.data.body is string
                    && request.resource.data.body.size() <= 2000
                    && request.resource.data.depth is number
                    && request.resource.data.depth <= 2;
      // Author can update (soft delete), counters updated by vote/reply system
      allow update: if request.auth != null;
      allow delete: if false; // Soft delete only

      // Comment votes subcollection
      match /votes/{oderId} {
        allow read: if request.auth != null;
        allow create, update: if request.auth != null
                              && request.auth.uid == oderId;
        allow delete: if request.auth != null
                      && request.auth.uid == oderId;
      }
    }

    // Drama Reports collection
    match /dramaReports/{reportId} {
      // Only the reporter can read their own report
      allow read: if request.auth != null
                  && resource.data.reporterId == request.auth.uid;
      // Authenticated users can create reports (must be the reporter)
      allow create: if request.auth != null
                    && request.resource.data.reporterId == request.auth.uid
                    && request.resource.data.reason is string
                    && request.resource.data.reason.size() <= 500;
      allow update, delete: if false; // Admin only
    }

    // Friend requests collection
    match /friendRequests/{requestId} {
      // Sender and receiver can read their own requests
      allow read: if request.auth != null
                  && (request.auth.uid == resource.data.fromId
                      || request.auth.uid == resource.data.toId);
      // Authenticated users can create friend requests (must be the sender)
      allow create: if request.auth != null
                    && request.resource.data.fromId == request.auth.uid;
      // Receiver can update (accept) the request
      allow update: if request.auth != null
                    && request.auth.uid == resource.data.toId;
      // Either party can delete (reject/cancel) the request
      allow delete: if request.auth != null
                    && (request.auth.uid == resource.data.fromId
                        || request.auth.uid == resource.data.toId);
    }
  }
}
